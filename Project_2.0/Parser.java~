import java.io.*;
import java.util.*;

class Parser {
	/*
	 * Code -> Prog STOP
     * Prog -> Decl Inst
     * Decl -> VAR var; EOL Decl | e
     * Inst -> var = Exp; EOL | DEBUT BlocInst FIN EOL | AVANCE Exp; EOL | TOURNE Exp; EOL | HAUTPINCEAU; EOL | BASPINCEAU; EOL
     *  | COULEUR Exp; EOL | EPAISSEUR Exp; EOL | SI Exp EOL ALORS Inst EOL InstSuite EOL | TANT QUE Exp EOL FAIRE Inst 
     *  | POUR Exp TOURS EOL Inst
     * InstSuite -> SINON Inst | e
     * BlocInst -> Inst BlocInst | e
	 * Exp -> int ExpSuite | var ExpSuite | (Exp) ExpSuite
	 * ExpSuite -> Op ExpSuite | e
     * Op -> + Exp | - Exp | * Exp | / Exp
	 */
    protected LookAhead1 reader;
    protected int pos;
    protected ValueEnvironment env;
    protected DrawPanel dp;

    public Parser(LookAhead1 r, ValueEnvironment e, DrawPanel d) {
	   reader = r;
	   env = e;
	   dp = d;
	   pos = 0;
    }   
    
    //Code -> Prog STOP
    public void nontermCode() throws Exception {
        Instruction prog = nontermProg();
        //prog.run(env, dp);
        //return prog;
    }
    
    //Prog -> Decl Inst
    public Instruction nontermProg() throws Exception {
    	if(reader.check(Sym.VAR)){
			Declaration decl = nontermDecl();
			return decl;
    	} else if(reader.check(Sym.VARIABLE)||reader.check(Sym.DEBUT)||
    	reader.check(Sym.AVANCE)||reader.check(Sym.TOURNE)||
    	reader.check(Sym.HAUT)||reader.check(Sym.BAS)
    	||reader.check(Sym.COULEUR)||reader.check(Sym.EPAISSEUR)
    	||reader.check(Sym.SI)||reader.check(Sym.TANTQUE)||reader.check(Sym.POUR)){
    		Instruction inst = nontermInst();
    		return inst;
    	
    	} else {
			dp.p_cp.wrongMessage("Erreur Instruction prog");
			throw new Exception();
    	}
    }

    //Decl -> VAR var; EOL Decl | e
    public Declaration nontermDecl() throws Exception {
    	if(reader.check(Sym.VAR)){
			term(Sym.VAR);
			String nomVar = reader.getStringValue();
			term(Sym.VARIABLE);
			term(Sym.CONCAT);
			Declaration decl = new Declaration(nomVar);
			decl.exec(env,dp);
			return decl;
		} else {
			dp.p_cp.wrongMessage("Erreur Declaration");
			throw new Exception();
		}
    }

    //Inst -> var = Exp; EOL | DEBUT BlocInst FIN EOL | AVANCE Exp; EOL | TOURNE Exp; EOL | HAUTPINCEAU; EOL | BASPINCEAU; EOL
    //  | COULEUR Exp; EOL | EPAISSEUR Exp; EOL | SI Exp EOL ALORS Inst EOL InstSuite EOL | TANT QUE Exp EOL FAIRE Inst 
    //  | POUR Exp TOURS EOL Inst
    public Instruction nontermInst() throws Exception {
    	if(reader.check(Sym.VARIABLE)){
			String nomVar = reader.getStringValue();
			term(Sym.VARIABLE);
			term(Sym.EQ);
			Expression exp = nontermExp();
			term(Sym.CONCAT);
			Assignment a = new Assignment(nomVar, exp);
			a.exec(env, dp);
			return a;
			/*
    	} else if(reader.check(Sym.DEBUT)) {
			term(Sym.DEBUT);
			BlocInst bloc = nontermBlocInst();
			term(Sym.FIN);
			return bloc;
			*/
    	} else if(reader.check(Sym.AVANCE)) {
			term(Sym.AVANCE);
			Expression exp = nontermExp();
			term(Sym.CONCAT);
			Move m = new Move(exp);
			m.exec(env, dp);
			return m;
    	} else if(reader.check(Sym.TOURNE)) {
			term(Sym.TOURNE);
			Expression exp = nontermExp();
			term(Sym.CONCAT);
			Turn t = new Turn(exp);
			t.exec(env, dp);
			return t;
    	}else if(reader.check(Sym.HAUT)) {
			term(Sym.HAUT);
			term(Sym.CONCAT);
			Position p = new Position(false);
			p.exec(env, dp);
			return p;
    	} else if(reader.check(Sym.BAS)) {
			term(Sym.BAS);
			term(Sym.CONCAT);
			Position p = new Position(true);
			p.exec(env, dp);
			return p;
    	} else if(reader.check(Sym.COULEUR)){
    		term(Sym.COULEUR);
    		Expression exp = nontermExp();
			term(Sym.CONCAT);
			Color c = new Color(exp);
			c.exec(env, dp);
			return c;
    	} else if (reader.check(Sym.EPAISSEUR)){
    		term(Sym.EPAISSEUR);
    		Expression exp = nontermExp();
			term(Sym.CONCAT);
			Size s = new Size(exp);
			s.exec(env, dp);
			return s;
			//SI Exp EOL ALORS Inst EOL InstSuite EOL | TANT QUE Exp EOL FAIRE Inst 
    		//  | POUR Exp TOURS EOL Inst
    	} else if(reader.check(Sym.SI)){
    		term(Sym.SI);
    		Expression exp = nontermExp();
    		term(Sym.ALORS);
    		Instruction inst = nontermInst();
    		If si = new If(exp, inst);
    		si.exec(env, dp);
    		return si;
    		//return nontermInstSuite(exp, inst);
    		/*
    	} else if(reader.check(Sym.TANTQUE)){
    		term(Sym.TANTQUE);
    		Expression exp = nontermExp();
    		term(Sym.FAIRE);
    		Instruction inst = nontermInst();
    		While w = new While(exp, inst);
    		w.exec(env, dp);
    		return w;
    	} else if(reader.check(Sym.POUR)){
			term(Sym.POUR);
			Expression exp = nontermExp();
			term(Sym.TOURS);
			Instruction inst= nontermInst();
			For f = new For(exp, inst);
			f.exec(env, dp);
			return f;
			*/
    	} else {
			dp.p_cp.wrongMessage("Erreur Instruction");
    	}
    }
/*
    public Instruction nontermInstSuite(Expression exp, Instruction inst) throws Exception {
		if(reader.check(Sym.SINON)) {
			term(Sym.SINON);
    		Instruction alt = nontermInst();
    		IfElse sinon = new IfElse(exp, inst, alt);
    		sinon.exec(env, dp);
    		return sinon;
		} else if(reader.check(Sym.VARIABLE)||reader.check(Sym.DEBUT)||
    	reader.check(Sym.AVANCE)||reader.check(Sym.TOURNE)||
    	reader.check(Sym.HAUT)||reader.check(Sym.BAS)
    	||reader.check(Sym.COULEUR)||reader.check(Sym.EPAISSEUR)
    	||reader.check(Sym.SI)||reader.check(Sym.TANTQUE)||reader.check(Sym.POUR)){
    		If si = new If(exp, inst);
    		si.exec(env, dp);
			return si;
    	} else {
			throw new ParserException("Erreur InstructionSuite", this.pos);
    	}
    }

    //BlocInst -> Inst; BlocInst | e
    public BlocInst nontermBlocInst() throws Exception {
    	if(reader.check(Sym.VARIABLE)||reader.check(Sym.DEBUT)||
    	reader.check(Sym.AVANCE)||reader.check(Sym.TOURNE)||
    	reader.check(Sym.HAUT)||reader.check(Sym.BAS)
    	||reader.check(Sym.COULEUR)||reader.check(Sym.EPAISSEUR)
    	||reader.check(Sym.SI)||reader.check(Sym.TANTQUE)||reader.check(Sym.POUR)){
			Instruction inst = nontermInst();
			BlocInst bloc = nontermBlocInst();
			return new BlocInst(inst, bloc);
    	} else {
    		if(reader.check(Sym.FIN)){
				return null;
			} else {
				throw new ParserException("Erreur BlocInst",this.pos);
			}
    	}
    }
*/
    //Exp -> int ExpSuite | var ExpSuite | (Exp) ExpSuite
    public Expression nontermExp() throws Exception {
    	if(reader.check(Sym.INT)){
			double value = reader.getIntValue();
			term(Sym.INT);
			Expression suite = nontermExpS(new Int(value));
			return suite;
    	} else if(reader.check(Sym.VARIABLE)) {
			String var = reader.getStringValue();
			term(Sym.VARIABLE);
			Expression suite = nontermExpS(new Var(var));
			return suite;
    	} else if(reader.check(Sym.LPAR)){
			term(Sym.LPAR);
			Expression exp = nontermExp();
			term(Sym.RPAR);
			//Specificité parenthèses??
			Expression expSuite = nontermExpS(exp);
			return expSuite;
    	} else {
			throw new ParserException("Erreur Expression",this.pos);
    	}
    }

    //ExpSuite -> Op ExpSuite | e
    public Expression nontermExpS(Expression beginning) throws Exception {
    	if(reader.check(Sym.PLUS)||reader.check(Sym.MINUS)||reader.check(Sym.TIMES)||reader.check(Sym.DIV)){
			Expression exp = nontermOp(beginning);
			Expression exp2 = nontermExpS(exp);
			return exp2;
		} else if(reader.check(Sym.CONCAT)||reader.check(Sym.ALORS)||reader.check(Sym.FAIRE)||reader.check(Sym.TOURS)||reader.check(Sym.RPAR)) {
		//in case of FOLLOW(ExpS) ie ExpS=e
			return beginning;
		} else {
			throw new ParserException("Erreur ExpressionSuite"+reader.getString(),this.pos);
		}
    }

    //Op -> + Exp | - Exp | * Exp | / Exp
    public Expression nontermOp(Expression beginning) throws Exception {
    	if(reader.check(Sym.PLUS)){
			term(Sym.PLUS);
			Expression exp = nontermExp();
			return new Sum(beginning, exp);
    	} else if(reader.check(Sym.MINUS)){
			term(Sym.MINUS);
			Expression exp = nontermExp();
			return new Difference(beginning, exp);
    	} else if(reader.check(Sym.TIMES)){
			term(Sym.TIMES);
			Expression exp = nontermExp();
			return new Product(beginning, exp);
    	} else if(reader.check(Sym.DIV)) {
			term(Sym.DIV);
			Expression exp = nontermExp();
			return new Division(beginning, exp);
    	} else {
			throw new ParserException("Erreur Opérateur",this.pos);
    	}
    }
    
    public void term(Sym symbol) throws Exception {
    	/*
		try{
			reader.eat(symbol);
		} catch(Exception e) {
			throw new Exception(e);
		}
		*/
		try{
			reader.eat(symbol);
			pos++;
		}catch(ReadException e){
			throw new ParserException("waiting for \""+e.getExpected()+"\" found \""+e.getFound()+"\"",this.pos);
		}
	}
}
